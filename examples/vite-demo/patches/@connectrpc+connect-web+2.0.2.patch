diff --git a/node_modules/@connectrpc/connect-web/dist/cjs/assert-fetch-api.d.ts b/node_modules/@connectrpc/connect-web/dist/cjs/assert-fetch-api.d.ts
index 61a0e60..b7728c9 100644
--- a/node_modules/@connectrpc/connect-web/dist/cjs/assert-fetch-api.d.ts
+++ b/node_modules/@connectrpc/connect-web/dist/cjs/assert-fetch-api.d.ts
@@ -2,3 +2,9 @@
  * Asserts that the fetch API is available.
  */
 export declare function assertFetchApi(): void;
+declare global {
+    interface RequestInit {
+        duplex?: string;
+    }
+}
+export declare const isRequestStreamsSupported: boolean;
diff --git a/node_modules/@connectrpc/connect-web/dist/cjs/assert-fetch-api.js b/node_modules/@connectrpc/connect-web/dist/cjs/assert-fetch-api.js
index a89a816..d450263 100644
--- a/node_modules/@connectrpc/connect-web/dist/cjs/assert-fetch-api.js
+++ b/node_modules/@connectrpc/connect-web/dist/cjs/assert-fetch-api.js
@@ -13,6 +13,7 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 Object.defineProperty(exports, "__esModule", { value: true });
+exports.isRequestStreamsSupported = void 0;
 exports.assertFetchApi = assertFetchApi;
 /**
  * Asserts that the fetch API is available.
@@ -25,3 +26,24 @@ function assertFetchApi() {
         throw new Error("connect-web requires the fetch API. Are you running on an old version of Node.js? Node.js is not supported in Connect for Web - please stay tuned for Connect for Node.");
     }
 }
+// Check the browser is supporting the duplex option
+// for the request stream.
+// https://developer.chrome.com/docs/capabilities/web-apis/fetch-streaming-requests#feature_detection
+function supportsRequestStreams() {
+    try {
+        let duplexAccessed = false;
+        const hasContentType = new Request("", {
+            body: new ReadableStream(),
+            method: "POST",
+            get duplex() {
+                duplexAccessed = true;
+                return "half";
+            },
+        }).headers.has("Content-Type");
+        return duplexAccessed && !hasContentType;
+    }
+    catch (_a) {
+        return false;
+    }
+}
+exports.isRequestStreamsSupported = supportsRequestStreams();
diff --git a/node_modules/@connectrpc/connect-web/dist/cjs/connect-transport.js b/node_modules/@connectrpc/connect-web/dist/cjs/connect-transport.js
index 8c4ced3..3c0ee28 100644
--- a/node_modules/@connectrpc/connect-web/dist/cjs/connect-transport.js
+++ b/node_modules/@connectrpc/connect-web/dist/cjs/connect-transport.js
@@ -25,6 +25,13 @@ var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _ar
     function reject(value) { resume("throw", value); }
     function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
 };
+var __asyncValues = (this && this.__asyncValues) || function (o) {
+    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
+    var m = o[Symbol.asyncIterator], i;
+    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
+    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
+    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
+};
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.createConnectTransport = createConnectTransport;
 const protobuf_1 = require("@bufbuild/protobuf");
@@ -146,14 +153,47 @@ function createConnectTransport(options) {
                 });
             }
             async function createRequestBody(input) {
-                if (method.methodKind != "server_streaming") {
-                    throw "The fetch API does not support streaming request bodies";
+                var _a, e_1, _b, _c;
+                if (method.methodKind == "server_streaming") {
+                    const r = await input[Symbol.asyncIterator]().next();
+                    if (r.done == true) {
+                        throw "missing request message";
+                    }
+                    return (0, protocol_1.encodeEnvelope)(0, serialize(r.value));
                 }
-                const r = await input[Symbol.asyncIterator]().next();
-                if (r.done == true) {
-                    throw "missing request message";
+                if (!assert_fetch_api_js_1.isRequestStreamsSupported) {
+                    // If the browser does not support the duplex option, we need to
+                    // buffer the entire request stream before sending it.
+                    const chunks = [];
+                    try {
+                        for (var _d = true, input_1 = __asyncValues(input), input_1_1; input_1_1 = await input_1.next(), _a = input_1_1.done, !_a; _d = true) {
+                            _c = input_1_1.value;
+                            _d = false;
+                            const chunk = _c;
+                            chunks.push(serialize(chunk));
+                        }
+                    }
+                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
+                    finally {
+                        try {
+                            if (!_d && !_a && (_b = input_1.return)) await _b.call(input_1);
+                        }
+                        finally { if (e_1) throw e_1.error; }
+                    }
+                    return (0, protocol_1.encodeEnvelope)(0, new Uint8Array(chunks.reduce((acc, chunk) => acc + chunk.length, 0)));
                 }
-                return (0, protocol_1.encodeEnvelope)(0, serialize(r.value));
+                const stream = new ReadableStream({
+                    async pull(controller) {
+                        const r = await input[Symbol.asyncIterator]().next();
+                        if (r.done == true) {
+                            controller.close();
+                            return;
+                        }
+                        const chunk = serialize(r.value);
+                        controller.enqueue((0, protocol_1.encodeEnvelope)(0, chunk));
+                    },
+                });
+                return stream;
             }
             timeoutMs =
                 timeoutMs === undefined
@@ -178,7 +218,9 @@ function createConnectTransport(options) {
                 next: async (req) => {
                     var _a;
                     const fetch = (_a = options.fetch) !== null && _a !== void 0 ? _a : globalThis.fetch;
-                    const fRes = await fetch(req.url, Object.assign(Object.assign({}, fetchOptions), { method: req.requestMethod, headers: req.header, signal: req.signal, body: await createRequestBody(req.message) }));
+                    const body = await createRequestBody(req.message);
+                    const isStreamBody = body instanceof ReadableStream;
+                    const fRes = await fetch(req.url, Object.assign(Object.assign(Object.assign({}, fetchOptions), { method: req.requestMethod, headers: req.header, signal: req.signal, body }), (isStreamBody ? { duplex: "half" } : {})));
                     (0, protocol_connect_1.validateResponse)(method.methodKind, useBinaryFormat, fRes.status, fRes.headers);
                     if (fRes.body === null) {
                         throw "missing response body";
diff --git a/node_modules/@connectrpc/connect-web/dist/cjs/fetch.spec.d.ts b/node_modules/@connectrpc/connect-web/dist/cjs/fetch.spec.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/@connectrpc/connect-web/dist/cjs/fetch.spec.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/@connectrpc/connect-web/dist/cjs/fetch.spec.js b/node_modules/@connectrpc/connect-web/dist/cjs/fetch.spec.js
new file mode 100644
index 0000000..ad535e5
--- /dev/null
+++ b/node_modules/@connectrpc/connect-web/dist/cjs/fetch.spec.js
@@ -0,0 +1,119 @@
+"use strict";
+// Copyright 2021-2025 The Connect Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+Object.defineProperty(exports, "__esModule", { value: true });
+const connect_conformance_1 = require("@connectrpc/connect-conformance");
+const connect_transport_js_1 = require("./connect-transport.js");
+const grpc_web_transport_js_1 = require("./grpc-web-transport.js");
+const protobuf_1 = require("@bufbuild/protobuf");
+describe("custom fetch", () => {
+    let originFetch;
+    beforeEach(() => {
+        originFetch = globalThis.fetch;
+    });
+    afterEach(() => {
+        globalThis.fetch = originFetch;
+    });
+    describe("with Connect transport", () => {
+        it("should only call Response#json with the JSON format", async () => {
+            const response = new Response((0, protobuf_1.toJsonString)(connect_conformance_1.UnaryResponseSchema, (0, protobuf_1.create)(connect_conformance_1.UnaryResponseSchema)), {
+                headers: {
+                    "Content-Type": "application/json",
+                },
+            });
+            spyOn(response, "arrayBuffer").and.callThrough();
+            spyOn(response, "json").and.callThrough();
+            const transport = (0, connect_transport_js_1.createConnectTransport)({
+                baseUrl: "https://example.com",
+                fetch: () => Promise.resolve(response),
+            });
+            await transport.unary(connect_conformance_1.ConformanceService.method.unary, undefined, undefined, undefined, (0, protobuf_1.create)(connect_conformance_1.UnaryRequestSchema));
+            expect(response.json).toHaveBeenCalledTimes(1);
+            expect(response.arrayBuffer).toHaveBeenCalledTimes(0);
+        });
+        it("should only call Response#arrayBuffer with the binary format on the happy path", async () => {
+            const response = new Response((0, protobuf_1.toBinary)(connect_conformance_1.UnaryResponseSchema, (0, protobuf_1.create)(connect_conformance_1.UnaryResponseSchema)), {
+                headers: {
+                    "Content-Type": "application/proto",
+                },
+            });
+            spyOn(response, "arrayBuffer").and.callThrough();
+            spyOn(response, "json").and.callThrough();
+            const transport = (0, connect_transport_js_1.createConnectTransport)({
+                fetch: () => Promise.resolve(response),
+                baseUrl: "https://example.com",
+                useBinaryFormat: true,
+            });
+            await transport.unary(connect_conformance_1.ConformanceService.method.unary, undefined, undefined, undefined, (0, protobuf_1.create)(connect_conformance_1.UnaryRequestSchema));
+            expect(response.json).toHaveBeenCalledTimes(0);
+            expect(response.arrayBuffer).toHaveBeenCalledTimes(1);
+        });
+        it("should call Response#json with the binary format for an error response", async () => {
+            const response = new Response(JSON.stringify({
+                code: "permission_denied",
+                message: "foobar",
+            }), {
+                status: 403,
+                headers: {
+                    "Content-Type": "application/json",
+                },
+            });
+            spyOn(response, "arrayBuffer").and.callThrough();
+            spyOn(response, "json").and.callThrough();
+            const transport = (0, connect_transport_js_1.createConnectTransport)({
+                fetch: () => Promise.resolve(response),
+                baseUrl: "https://example.com",
+                useBinaryFormat: true,
+            });
+            await expectAsync(transport.unary(connect_conformance_1.ConformanceService.method.unary, undefined, undefined, undefined, (0, protobuf_1.create)(connect_conformance_1.UnaryRequestSchema))).toBeRejectedWithError(/\[permission_denied] foobar/);
+            expect(response.json).toHaveBeenCalledTimes(1);
+            expect(response.arrayBuffer).toHaveBeenCalledTimes(0);
+        });
+        it("should should defer resolving fetch until calling endpoint", async () => {
+            const response = new Response((0, protobuf_1.toJsonString)(connect_conformance_1.UnaryResponseSchema, (0, protobuf_1.create)(connect_conformance_1.UnaryResponseSchema)), {
+                headers: {
+                    "Content-Type": "application/json",
+                },
+            });
+            spyOn(response, "arrayBuffer").and.callThrough();
+            spyOn(response, "json").and.callThrough();
+            const transport = (0, connect_transport_js_1.createConnectTransport)({
+                baseUrl: "https://example.com",
+            });
+            // Patch globalThis.fetch to mimic a polyfill or patch
+            globalThis.fetch = () => Promise.resolve(response);
+            await transport.unary(connect_conformance_1.ConformanceService.method.unary, undefined, undefined, undefined, (0, protobuf_1.create)(connect_conformance_1.UnaryRequestSchema));
+            expect(response.json).toHaveBeenCalledTimes(1);
+            expect(response.arrayBuffer).toHaveBeenCalledTimes(0);
+        });
+    });
+    describe("with gRPC-web transport", () => {
+        it("should should defer resolving fetch until calling endpoint", async () => {
+            const response = new Response((0, protobuf_1.toJsonString)(connect_conformance_1.UnaryResponseSchema, (0, protobuf_1.create)(connect_conformance_1.UnaryResponseSchema)), {
+                headers: {
+                    "Content-Type": "application/json",
+                },
+            });
+            spyOn(response, "arrayBuffer").and.callThrough();
+            spyOn(response, "json").and.callThrough();
+            const transport = (0, grpc_web_transport_js_1.createGrpcWebTransport)({
+                baseUrl: "https://example.com",
+                useBinaryFormat: false,
+            });
+            // Patch globalThis.fetch to mimic a polyfill or patch
+            globalThis.fetch = () => Promise.reject("test-error-raised-from-patched-fetch");
+            await expectAsync(transport.unary(connect_conformance_1.ConformanceService.method.unary, undefined, undefined, undefined, (0, protobuf_1.create)(connect_conformance_1.UnaryRequestSchema))).toBeRejectedWithError(/test-error-raised-from-patched-fetch/);
+        });
+    });
+});
diff --git a/node_modules/@connectrpc/connect-web/dist/cjs/grpc-web-transport.js b/node_modules/@connectrpc/connect-web/dist/cjs/grpc-web-transport.js
index 8916779..fcdd02c 100644
--- a/node_modules/@connectrpc/connect-web/dist/cjs/grpc-web-transport.js
+++ b/node_modules/@connectrpc/connect-web/dist/cjs/grpc-web-transport.js
@@ -25,6 +25,13 @@ var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _ar
     function reject(value) { resume("throw", value); }
     function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
 };
+var __asyncValues = (this && this.__asyncValues) || function (o) {
+    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
+    var m = o[Symbol.asyncIterator], i;
+    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
+    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
+    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
+};
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.createGrpcWebTransport = createGrpcWebTransport;
 const connect_1 = require("@connectrpc/connect");
@@ -187,14 +194,47 @@ function createGrpcWebTransport(options) {
                 });
             }
             async function createRequestBody(input) {
-                if (method.methodKind != "server_streaming") {
-                    throw "The fetch API does not support streaming request bodies";
+                var _a, e_1, _b, _c;
+                if (method.methodKind == "server_streaming") {
+                    const r = await input[Symbol.asyncIterator]().next();
+                    if (r.done == true) {
+                        throw "missing request message";
+                    }
+                    return (0, protocol_1.encodeEnvelope)(0, serialize(r.value));
                 }
-                const r = await input[Symbol.asyncIterator]().next();
-                if (r.done == true) {
-                    throw "missing request message";
+                if (!assert_fetch_api_js_1.isRequestStreamsSupported) {
+                    // If the browser does not support the duplex option, we need to
+                    // buffer the entire request stream before sending it.
+                    const chunks = [];
+                    try {
+                        for (var _d = true, input_1 = __asyncValues(input), input_1_1; input_1_1 = await input_1.next(), _a = input_1_1.done, !_a; _d = true) {
+                            _c = input_1_1.value;
+                            _d = false;
+                            const chunk = _c;
+                            chunks.push(serialize(chunk));
+                        }
+                    }
+                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
+                    finally {
+                        try {
+                            if (!_d && !_a && (_b = input_1.return)) await _b.call(input_1);
+                        }
+                        finally { if (e_1) throw e_1.error; }
+                    }
+                    return (0, protocol_1.encodeEnvelope)(0, new Uint8Array(chunks.reduce((acc, chunk) => acc + chunk.length, 0)));
                 }
-                return (0, protocol_1.encodeEnvelope)(0, serialize(r.value));
+                const stream = new ReadableStream({
+                    async pull(controller) {
+                        const r = await input[Symbol.asyncIterator]().next();
+                        if (r.done == true) {
+                            controller.close();
+                            return;
+                        }
+                        const chunk = serialize(r.value);
+                        controller.enqueue((0, protocol_1.encodeEnvelope)(0, chunk));
+                    },
+                });
+                return stream;
             }
             timeoutMs =
                 timeoutMs === undefined
@@ -219,7 +259,9 @@ function createGrpcWebTransport(options) {
                 next: async (req) => {
                     var _a;
                     const fetch = (_a = options.fetch) !== null && _a !== void 0 ? _a : globalThis.fetch;
-                    const fRes = await fetch(req.url, Object.assign(Object.assign({}, fetchOptions), { method: req.requestMethod, headers: req.header, signal: req.signal, body: await createRequestBody(req.message) }));
+                    const body = await createRequestBody(req.message);
+                    const isStreamBody = body instanceof ReadableStream;
+                    const fRes = await fetch(req.url, Object.assign(Object.assign(Object.assign({}, fetchOptions), { method: req.requestMethod, headers: req.header, signal: req.signal, body }), (isStreamBody ? { duplex: "half" } : {})));
                     const { foundStatus, headerError } = (0, protocol_grpc_web_1.validateResponse)(fRes.status, fRes.headers);
                     if (headerError != undefined) {
                         throw headerError;
diff --git a/node_modules/@connectrpc/connect-web/dist/esm/assert-fetch-api.d.ts b/node_modules/@connectrpc/connect-web/dist/esm/assert-fetch-api.d.ts
index 61a0e60..b7728c9 100644
--- a/node_modules/@connectrpc/connect-web/dist/esm/assert-fetch-api.d.ts
+++ b/node_modules/@connectrpc/connect-web/dist/esm/assert-fetch-api.d.ts
@@ -2,3 +2,9 @@
  * Asserts that the fetch API is available.
  */
 export declare function assertFetchApi(): void;
+declare global {
+    interface RequestInit {
+        duplex?: string;
+    }
+}
+export declare const isRequestStreamsSupported: boolean;
diff --git a/node_modules/@connectrpc/connect-web/dist/esm/assert-fetch-api.js b/node_modules/@connectrpc/connect-web/dist/esm/assert-fetch-api.js
index 74fd4e8..1e04f0d 100644
--- a/node_modules/@connectrpc/connect-web/dist/esm/assert-fetch-api.js
+++ b/node_modules/@connectrpc/connect-web/dist/esm/assert-fetch-api.js
@@ -22,3 +22,24 @@ export function assertFetchApi() {
         throw new Error("connect-web requires the fetch API. Are you running on an old version of Node.js? Node.js is not supported in Connect for Web - please stay tuned for Connect for Node.");
     }
 }
+// Check the browser is supporting the duplex option
+// for the request stream.
+// https://developer.chrome.com/docs/capabilities/web-apis/fetch-streaming-requests#feature_detection
+function supportsRequestStreams() {
+    try {
+        let duplexAccessed = false;
+        const hasContentType = new Request("", {
+            body: new ReadableStream(),
+            method: "POST",
+            get duplex() {
+                duplexAccessed = true;
+                return "half";
+            },
+        }).headers.has("Content-Type");
+        return duplexAccessed && !hasContentType;
+    }
+    catch (_a) {
+        return false;
+    }
+}
+export const isRequestStreamsSupported = supportsRequestStreams();
diff --git a/node_modules/@connectrpc/connect-web/dist/esm/connect-transport.js b/node_modules/@connectrpc/connect-web/dist/esm/connect-transport.js
index 31294b5..b4cdf9a 100644
--- a/node_modules/@connectrpc/connect-web/dist/esm/connect-transport.js
+++ b/node_modules/@connectrpc/connect-web/dist/esm/connect-transport.js
@@ -24,11 +24,18 @@ var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _ar
     function reject(value) { resume("throw", value); }
     function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
 };
+var __asyncValues = (this && this.__asyncValues) || function (o) {
+    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
+    var m = o[Symbol.asyncIterator], i;
+    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
+    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
+    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
+};
 import { fromJson } from "@bufbuild/protobuf";
 import { Code, ConnectError, appendHeaders, createContextValues, } from "@connectrpc/connect";
 import { createClientMethodSerializers, createEnvelopeReadableStream, createMethodUrl, getJsonOptions, encodeEnvelope, runStreamingCall, runUnaryCall, compressedFlag, } from "@connectrpc/connect/protocol";
 import { endStreamFlag, endStreamFromJson, errorFromJson, requestHeader, trailerDemux, transformConnectPostToGetRequest, validateResponse, } from "@connectrpc/connect/protocol-connect";
-import { assertFetchApi } from "./assert-fetch-api.js";
+import { assertFetchApi, isRequestStreamsSupported, } from "./assert-fetch-api.js";
 import { MethodOptions_IdempotencyLevel } from "@bufbuild/protobuf/wkt";
 const fetchOptions = {
     redirect: "error",
@@ -143,14 +150,47 @@ export function createConnectTransport(options) {
                 });
             }
             async function createRequestBody(input) {
-                if (method.methodKind != "server_streaming") {
-                    throw "The fetch API does not support streaming request bodies";
+                var _a, e_1, _b, _c;
+                if (method.methodKind == "server_streaming") {
+                    const r = await input[Symbol.asyncIterator]().next();
+                    if (r.done == true) {
+                        throw "missing request message";
+                    }
+                    return encodeEnvelope(0, serialize(r.value));
                 }
-                const r = await input[Symbol.asyncIterator]().next();
-                if (r.done == true) {
-                    throw "missing request message";
+                if (!isRequestStreamsSupported) {
+                    // If the browser does not support the duplex option, we need to
+                    // buffer the entire request stream before sending it.
+                    const chunks = [];
+                    try {
+                        for (var _d = true, input_1 = __asyncValues(input), input_1_1; input_1_1 = await input_1.next(), _a = input_1_1.done, !_a; _d = true) {
+                            _c = input_1_1.value;
+                            _d = false;
+                            const chunk = _c;
+                            chunks.push(serialize(chunk));
+                        }
+                    }
+                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
+                    finally {
+                        try {
+                            if (!_d && !_a && (_b = input_1.return)) await _b.call(input_1);
+                        }
+                        finally { if (e_1) throw e_1.error; }
+                    }
+                    return encodeEnvelope(0, new Uint8Array(chunks.reduce((acc, chunk) => acc + chunk.length, 0)));
                 }
-                return encodeEnvelope(0, serialize(r.value));
+                const stream = new ReadableStream({
+                    async pull(controller) {
+                        const r = await input[Symbol.asyncIterator]().next();
+                        if (r.done == true) {
+                            controller.close();
+                            return;
+                        }
+                        const chunk = serialize(r.value);
+                        controller.enqueue(encodeEnvelope(0, chunk));
+                    },
+                });
+                return stream;
             }
             timeoutMs =
                 timeoutMs === undefined
@@ -175,7 +215,9 @@ export function createConnectTransport(options) {
                 next: async (req) => {
                     var _a;
                     const fetch = (_a = options.fetch) !== null && _a !== void 0 ? _a : globalThis.fetch;
-                    const fRes = await fetch(req.url, Object.assign(Object.assign({}, fetchOptions), { method: req.requestMethod, headers: req.header, signal: req.signal, body: await createRequestBody(req.message) }));
+                    const body = await createRequestBody(req.message);
+                    const isStreamBody = body instanceof ReadableStream;
+                    const fRes = await fetch(req.url, Object.assign(Object.assign(Object.assign({}, fetchOptions), { method: req.requestMethod, headers: req.header, signal: req.signal, body }), (isStreamBody ? { duplex: "half" } : {})));
                     validateResponse(method.methodKind, useBinaryFormat, fRes.status, fRes.headers);
                     if (fRes.body === null) {
                         throw "missing response body";
diff --git a/node_modules/@connectrpc/connect-web/dist/esm/fetch.spec.d.ts b/node_modules/@connectrpc/connect-web/dist/esm/fetch.spec.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/@connectrpc/connect-web/dist/esm/fetch.spec.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/@connectrpc/connect-web/dist/esm/fetch.spec.js b/node_modules/@connectrpc/connect-web/dist/esm/fetch.spec.js
new file mode 100644
index 0000000..a141e34
--- /dev/null
+++ b/node_modules/@connectrpc/connect-web/dist/esm/fetch.spec.js
@@ -0,0 +1,117 @@
+// Copyright 2021-2025 The Connect Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+import { ConformanceService, UnaryRequestSchema, UnaryResponseSchema, } from "@connectrpc/connect-conformance";
+import { createConnectTransport } from "./connect-transport.js";
+import { createGrpcWebTransport } from "./grpc-web-transport.js";
+import { create, toBinary, toJsonString } from "@bufbuild/protobuf";
+describe("custom fetch", () => {
+    let originFetch;
+    beforeEach(() => {
+        originFetch = globalThis.fetch;
+    });
+    afterEach(() => {
+        globalThis.fetch = originFetch;
+    });
+    describe("with Connect transport", () => {
+        it("should only call Response#json with the JSON format", async () => {
+            const response = new Response(toJsonString(UnaryResponseSchema, create(UnaryResponseSchema)), {
+                headers: {
+                    "Content-Type": "application/json",
+                },
+            });
+            spyOn(response, "arrayBuffer").and.callThrough();
+            spyOn(response, "json").and.callThrough();
+            const transport = createConnectTransport({
+                baseUrl: "https://example.com",
+                fetch: () => Promise.resolve(response),
+            });
+            await transport.unary(ConformanceService.method.unary, undefined, undefined, undefined, create(UnaryRequestSchema));
+            expect(response.json).toHaveBeenCalledTimes(1);
+            expect(response.arrayBuffer).toHaveBeenCalledTimes(0);
+        });
+        it("should only call Response#arrayBuffer with the binary format on the happy path", async () => {
+            const response = new Response(toBinary(UnaryResponseSchema, create(UnaryResponseSchema)), {
+                headers: {
+                    "Content-Type": "application/proto",
+                },
+            });
+            spyOn(response, "arrayBuffer").and.callThrough();
+            spyOn(response, "json").and.callThrough();
+            const transport = createConnectTransport({
+                fetch: () => Promise.resolve(response),
+                baseUrl: "https://example.com",
+                useBinaryFormat: true,
+            });
+            await transport.unary(ConformanceService.method.unary, undefined, undefined, undefined, create(UnaryRequestSchema));
+            expect(response.json).toHaveBeenCalledTimes(0);
+            expect(response.arrayBuffer).toHaveBeenCalledTimes(1);
+        });
+        it("should call Response#json with the binary format for an error response", async () => {
+            const response = new Response(JSON.stringify({
+                code: "permission_denied",
+                message: "foobar",
+            }), {
+                status: 403,
+                headers: {
+                    "Content-Type": "application/json",
+                },
+            });
+            spyOn(response, "arrayBuffer").and.callThrough();
+            spyOn(response, "json").and.callThrough();
+            const transport = createConnectTransport({
+                fetch: () => Promise.resolve(response),
+                baseUrl: "https://example.com",
+                useBinaryFormat: true,
+            });
+            await expectAsync(transport.unary(ConformanceService.method.unary, undefined, undefined, undefined, create(UnaryRequestSchema))).toBeRejectedWithError(/\[permission_denied] foobar/);
+            expect(response.json).toHaveBeenCalledTimes(1);
+            expect(response.arrayBuffer).toHaveBeenCalledTimes(0);
+        });
+        it("should should defer resolving fetch until calling endpoint", async () => {
+            const response = new Response(toJsonString(UnaryResponseSchema, create(UnaryResponseSchema)), {
+                headers: {
+                    "Content-Type": "application/json",
+                },
+            });
+            spyOn(response, "arrayBuffer").and.callThrough();
+            spyOn(response, "json").and.callThrough();
+            const transport = createConnectTransport({
+                baseUrl: "https://example.com",
+            });
+            // Patch globalThis.fetch to mimic a polyfill or patch
+            globalThis.fetch = () => Promise.resolve(response);
+            await transport.unary(ConformanceService.method.unary, undefined, undefined, undefined, create(UnaryRequestSchema));
+            expect(response.json).toHaveBeenCalledTimes(1);
+            expect(response.arrayBuffer).toHaveBeenCalledTimes(0);
+        });
+    });
+    describe("with gRPC-web transport", () => {
+        it("should should defer resolving fetch until calling endpoint", async () => {
+            const response = new Response(toJsonString(UnaryResponseSchema, create(UnaryResponseSchema)), {
+                headers: {
+                    "Content-Type": "application/json",
+                },
+            });
+            spyOn(response, "arrayBuffer").and.callThrough();
+            spyOn(response, "json").and.callThrough();
+            const transport = createGrpcWebTransport({
+                baseUrl: "https://example.com",
+                useBinaryFormat: false,
+            });
+            // Patch globalThis.fetch to mimic a polyfill or patch
+            globalThis.fetch = () => Promise.reject("test-error-raised-from-patched-fetch");
+            await expectAsync(transport.unary(ConformanceService.method.unary, undefined, undefined, undefined, create(UnaryRequestSchema))).toBeRejectedWithError(/test-error-raised-from-patched-fetch/);
+        });
+    });
+});
diff --git a/node_modules/@connectrpc/connect-web/dist/esm/grpc-web-transport.js b/node_modules/@connectrpc/connect-web/dist/esm/grpc-web-transport.js
index 9aebd23..7d77976 100644
--- a/node_modules/@connectrpc/connect-web/dist/esm/grpc-web-transport.js
+++ b/node_modules/@connectrpc/connect-web/dist/esm/grpc-web-transport.js
@@ -24,10 +24,17 @@ var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _ar
     function reject(value) { resume("throw", value); }
     function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
 };
+var __asyncValues = (this && this.__asyncValues) || function (o) {
+    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
+    var m = o[Symbol.asyncIterator], i;
+    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
+    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
+    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
+};
 import { createContextValues, ConnectError, Code } from "@connectrpc/connect";
 import { compressedFlag, createClientMethodSerializers, createEnvelopeReadableStream, createMethodUrl, encodeEnvelope, runStreamingCall, runUnaryCall, } from "@connectrpc/connect/protocol";
 import { headerGrpcStatus, requestHeader, trailerFlag, trailerParse, validateResponse, validateTrailer, } from "@connectrpc/connect/protocol-grpc-web";
-import { assertFetchApi } from "./assert-fetch-api.js";
+import { assertFetchApi, isRequestStreamsSupported, } from "./assert-fetch-api.js";
 const fetchOptions = {
     redirect: "error",
 };
@@ -184,14 +191,47 @@ export function createGrpcWebTransport(options) {
                 });
             }
             async function createRequestBody(input) {
-                if (method.methodKind != "server_streaming") {
-                    throw "The fetch API does not support streaming request bodies";
+                var _a, e_1, _b, _c;
+                if (method.methodKind == "server_streaming") {
+                    const r = await input[Symbol.asyncIterator]().next();
+                    if (r.done == true) {
+                        throw "missing request message";
+                    }
+                    return encodeEnvelope(0, serialize(r.value));
                 }
-                const r = await input[Symbol.asyncIterator]().next();
-                if (r.done == true) {
-                    throw "missing request message";
+                if (!isRequestStreamsSupported) {
+                    // If the browser does not support the duplex option, we need to
+                    // buffer the entire request stream before sending it.
+                    const chunks = [];
+                    try {
+                        for (var _d = true, input_1 = __asyncValues(input), input_1_1; input_1_1 = await input_1.next(), _a = input_1_1.done, !_a; _d = true) {
+                            _c = input_1_1.value;
+                            _d = false;
+                            const chunk = _c;
+                            chunks.push(serialize(chunk));
+                        }
+                    }
+                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
+                    finally {
+                        try {
+                            if (!_d && !_a && (_b = input_1.return)) await _b.call(input_1);
+                        }
+                        finally { if (e_1) throw e_1.error; }
+                    }
+                    return encodeEnvelope(0, new Uint8Array(chunks.reduce((acc, chunk) => acc + chunk.length, 0)));
                 }
-                return encodeEnvelope(0, serialize(r.value));
+                const stream = new ReadableStream({
+                    async pull(controller) {
+                        const r = await input[Symbol.asyncIterator]().next();
+                        if (r.done == true) {
+                            controller.close();
+                            return;
+                        }
+                        const chunk = serialize(r.value);
+                        controller.enqueue(encodeEnvelope(0, chunk));
+                    },
+                });
+                return stream;
             }
             timeoutMs =
                 timeoutMs === undefined
@@ -216,7 +256,9 @@ export function createGrpcWebTransport(options) {
                 next: async (req) => {
                     var _a;
                     const fetch = (_a = options.fetch) !== null && _a !== void 0 ? _a : globalThis.fetch;
-                    const fRes = await fetch(req.url, Object.assign(Object.assign({}, fetchOptions), { method: req.requestMethod, headers: req.header, signal: req.signal, body: await createRequestBody(req.message) }));
+                    const body = await createRequestBody(req.message);
+                    const isStreamBody = body instanceof ReadableStream;
+                    const fRes = await fetch(req.url, Object.assign(Object.assign(Object.assign({}, fetchOptions), { method: req.requestMethod, headers: req.header, signal: req.signal, body }), (isStreamBody ? { duplex: "half" } : {})));
                     const { foundStatus, headerError } = validateResponse(fRes.status, fRes.headers);
                     if (headerError != undefined) {
                         throw headerError;
